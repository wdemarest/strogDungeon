<!DOCTYPE html>
<html>
	<head>
		<style type="text/css">
			#health {
				font-size: 25px;
				font-family:  "Lucida Console", Monaco, monospace;
				line-height: 2;
				letter-spacing: -0.1px;
			}
			#map {
				font-size: 40px;
				font-family:  "Lucida Console", Monaco, monospace;
				white-space: pre-wrap;
				line-height: 1;
				letter-spacing: -0.4px;
			}
			#eventLog {
				font-size: 25px;
				line-height: 1;
				white-space: pre-wrap;
			}
		</style>
		<script
  src="https://code.jquery.com/jquery-3.3.1.js"
  integrity="sha256-2Kok7MbOyxpgUVvAk/HJ2jigOSYS2auK4Pfzbm7uH60="
  crossorigin="anonymous"></script>
		<script>

			let loggedEvents = 0;
			let eventLog = [];

			function logEvent(message){
				if (loggedEvents <= 0){
					eventLog.unshift("\n");
					loggedEvents ++;
				}
				eventLog.unshift(message+"\n");
				$("#eventLog").html(eventLog);
				while (eventLog.length > 40){
					eventLog.pop();
				}
				loggedEvents ++;
			}

			class Map {
				constructor(tileKey){
					this.width = 0;
					this.height = 0;
					this.tileList = null;
					this.tileKey = tileKey

				}

				inBounds(xPos, yPos){
					console.assert(xPos !== undefined)
					console.assert(yPos !== undefined)
					return !(yPos > this.height || xPos > this.width || yPos < 0 || xPos < 0);
				}

				tileDefined(xPos, yPos){
					let index = xPos+yPos*(this.width);
					let tile = this.tileList[index];
					console.assert(tile !== undefined);
				}

				scan(procedure){
					for (let y = 0; y < this.height; y++) {
						for (let x = 0; x < this.width; x++) {
							procedure(x, y)
						}
					}
				}


				initFromMapData(mapData){
					console.assert(typeof mapData.width == "number" && mapData.width > 0)
					console.assert(typeof mapData.height == "number" && mapData.height > 0)
					//Map data is an array and tileList.length is what it should be.
					console.assert(Array.isArray(mapData.tileList) && mapData.tileList.length == mapData.width * mapData.height)
					this.width = mapData.width;
					this.height = mapData.height;
					this.tileList = mapData.tileList;
					return this;
				}

				find(name){
					if(!name){
						debugger;
					}

					let result = [];					
					this.scan((x, y) => {
						let tileFound = this.getTile(x, y);
						if (tileFound.name == name){
							result.push({ tile:tileFound, x:x, y:y });
						}
					});
					return result;
				}

				setTile(xPos, yPos, setTo){
					if(!this.inBounds(xPos, yPos)){
						return false;
					}

					this.tileDefined(xPos, yPos);
					
					let index = xPos+yPos*this.width;
					let tile = this.tileList[index];
					console.assert(tile !== undefined);
					this.tileList[index] = setTo;
				}

				getTile(xPos, yPos){
					if (this.tileList.length <= 1){
						debugger;
					}
					if(!this.inBounds(xPos, yPos)){
						return false;
					}

					this.tileDefined(xPos, yPos);

					let index = xPos+yPos*(this.width);
					let tile = this.tileList[index];
					console.assert(tile !== undefined);
					return tile;
				}

				moveTile(startXPos, startYPos, endXPos, endYPos){
					let tileMoved = this.getTile(startXPos, startYPos);
					this.setTile(startXPos, startYPos, {name: "floor"})
					this.setTile(endXPos, endYPos, tileMoved)
				}

				render(){
					let map = "";
					this.scan( (x, y) => {
						let character = this.tileKey[this.getTile(x, y).name];
						map += character+(x == this.width-1 ? "\n" : "" );
					});
					return map;
				}
				

			}

			class Screen{
				drawMap(map){
					$("#map").html(map.render());
				}
				displayHealth(player){
					let healthDisplay = "";
					if (player != undefined){
						for (let i = 0; i < player.tile.maxHealth; i++) {
							healthDisplay += (i < player.tile.health ? "█" : "_");
						};
					}else{
						healthDisplay = "";
					}
					$("#health").html(healthDisplay);
				}
			}

			function loadMapData(mapId){
				let mapList = {}

				mapList.main = {height: 8, width: 10, tileList: [
					{name: "wall"}, {name: "wall"}, {name: "wall"}, {name: "wall"}, {name: "wall"}, {name: "wall"}, {name: "wall"}, {name: "wall"}, {name: "wall"}, {name: "wall"},
					{name: "wall"}, {name: "wall"}, {name: "end"}, {name: "floor"}, {name: "floor"}, {name: "wall"}, {name: "wall"}, {name: "wall"}, {name: "wall"}, {name: "wall"},
					{name: "wall"}, {name: "floor"}, {name: "orc", health: 2}, {name: "floor"}, {name: "floor"}, {name: "wall"}, {name: "wall"}, {name: "wall"}, {name: "wall"}, {name: "wall"},
					{name: "wall"}, {name: "floor"}, {name: "floor"}, {name: "floor"}, {name: "floor"}, {name: "wall"}, {name: "floor"}, {name: "floor"}, {name: "floor"}, {name: "wall"},
					{name: "wall"}, {name: "floor"}, {name: "floor"}, {name: "floor"}, {name: "orc", health: 2}, {name: "wall"}, {name: "floor"}, {name: "floor"}, {name: "orc", health: 2}, {name: "wall"},
					{name: "wall"}, {name: "floor"}, {name: "floor"}, {name: "floor"}, {name: "floor"}, {name: "wall"}, {name: "floor"}, {name: "floor"}, {name: "floor"}, {name: "wall"},
					{name: "wall"}, {name: "player", health: 10, maxHealth: 10}, {name: "floor"}, {name: "floor"}, {name: "floor"}, {name: "floor"}, {name: "floor"}, {name: "floor"}, {name: "floor"}, {name: "wall"},
					{name: "wall"}, {name: "wall"}, {name: "wall"}, {name: "wall"}, {name: "wall"}, {name: "wall"}, {name: "wall"}, {name: "wall"}, {name: "wall"}, {name: "wall"}
				]};

				mapList.win = {width: 11, height: 3, tileList:[
					{name: "wall"}, {name: "floor"}, {name: "wall"}, {name: "floor"}, {name: "wall"}, {name: "floor"}, {name: "player"}, {name: "floor"}, {name: "wall"}, {name: "wall"}, {name: "wall"},
					{name: "wall"}, {name: "floor"}, {name: "wall"}, {name: "floor"}, {name: "wall"}, {name: "floor"}, {name: "wall"}, {name: "floor"}, {name: "wall"},  {name: "floor"}, {name: "wall"},
					{name: "floor"}, {name: "wall"}, {name: "floor"}, {name: "wall"}, {name: "floor"}, {name: "floor"}, {name: "wall"}, {name: "floor"}, {name: "wall"},  {name: "floor"}, {name: "wall"}
				]};

				return mapList[mapId];

			}

			//player AI
			function recieveInput(keyCode, entity){
				let action = {x: entity.x, y: entity.y};

				if (keyCode == 65){
					action.x -= 1;
				};
				if (keyCode == 87){
					action.y -= 1;
				};
				if (keyCode == 68){
					action.x += 1;
				};
				if (keyCode == 88){
					action.y += 1;
				};
				
				if (keyCode == 81){
					action.x -= 1;
					action.y -= 1;
				};
				if (keyCode == 69){
					action.x += 1;
					action.y -= 1;
				};
				if (keyCode == 67){
					action.x += 1;
					action.y += 1;
				};
				if (keyCode == 90){
					action.x -= 1;
					action.y += 1;
				};

				return action;
			}

			function playerDetermineCommand(map, action){
				let targetName = map.getTile(action.x, action.y).name;
				
				if (targetName == "floor"){
					action.command = "move";
				};
				if (targetName == "orc"){
					action.command = "attack";
				};
				if (targetName == "wall"){
					action.command = "bump";
				};
				if (targetName == "end"){
					action.command = "win";
				};
				if (targetName == "player"){
					action.command = "wait";
				};
				return action;
			};

			//orc AI
			function orcAI(entity, map){
				let action;
				let player = map.find("player")[0];
				let enemy = (player ? player : entity);
				if (Math.abs(enemy.x-entity.x) <= 1 && Math.abs(enemy.y-entity.y) <= 1){
					action = {command: "attack", x: enemy.x, y: enemy.y};
				}else{
					action = {command: "move", x: entity.x, y: entity.y};

					if (enemy.x != entity.x) {
						action.x += (enemy.x > entity.x ? 1 : -1)
					};

					if (enemy.y != entity.y) {
						action.y += (enemy.y > entity.y ? 1 : -1)
					};
				}
				return action;
			}

			function moveEntity(map, entity, x, y){
				map.moveTile(entity.x, entity.y, x, y)
				entity.x = x;
				entity.y = y;
			}

			function checkDeath(entity, map){
				if (entity.tile.health <= 0){
					map.setTile(entity.x, entity.y, {name: "floor"})
					if (entity.tile.name == "orc"){
						logEvent("You killed the orc.")
					}
					if (entity.tile.name == "player"){
						logEvent("YER DEAD!")
					}
				}
			}

			function ai(map, entity, keyCode){
				let action;
				if (entity.tile.name == "player"){
					action = recieveInput(keyCode, entity);
					action = playerDetermineCommand(map, action);
				}else{
					action = orcAI(entity, map);
				}
				return action;
			}

			function act(map, entity, action){
				if(!action){
					debugger;
				}
				if(action.command == "move"){
					if (map.getTile(action.x, action.y).name == "floor"){
						moveEntity(map, entity, action.x, action.y)
					}else{
						if (entity.tile.name == "player") {
							logEvent("You ram your head into the wall like a moron.");
						}
					}
				}
				if(action.command == "attack"){
					map.getTile(action.x, action.y).health -= 1;
					if(entity.tile.name == "player"){
						logEvent("You hit the orc.");
					}
					if(entity.tile.name == "orc"){
						logEvent("The orc hits you.");
					}
				}
				if(action.command == "win"){
					map.mapToSet = "win";
					logEvent("YOU WIN!")
				}
				if(action.command == "wait"){
					if (entity.tile.name == "player") {
						logEvent("You wait.");
					}
				}
			}

			function run(keyCode, map){

				function makeEntityList(map){
					let entityList = [];
					entityList = entityList.concat(map.find("player"));
					entityList = entityList.concat(map.find("orc"));
					return entityList;
				}

				function simTiles(){
					let entityList = makeEntityList(map);
					for (let entity of entityList){
						let action = ai(map, entity, keyCode);
						act(map, entity, action);
						if(map.mapToSet){return;}
					}
					for (let entity of entityList){
						checkDeath(entity, map);
					}
				}

				loggedEvents = 0;

				simTiles();
			};
			
			function main(){
				let tileKey = {wall: "█", floor: ".", orc: "O", player: "±", end: "E"};
				let map = new Map(tileKey);
				let mapData = loadMapData("main");
				map.initFromMapData(mapData);

				let screen = new Screen();

				function allTheStuff(e) {
					run(e.keyCode, map);
					if(map.mapToSet){
						map = new Map(tileKey).initFromMapData(loadMapData(map.mapToSet));
					}

					screen.drawMap(map)
					screen.displayHealth(map.find("player")[0]);
				};

				$( document ).keydown(allTheStuff);
				
				screen.drawMap(map)
				screen.displayHealth(map.find("player")[0]);

				logEvent("W = up. A = left. D = right. X = down. Q = up/left. E = up/right Z = down/left C = down/right");
			}

			$( document ).ready(function() {
			 	main();
			});

			/*
			Alpha 1.1
			- better orc AI
			- different enemies
			- death screen
			- eventlog ends when dead

			GIANT BUGS OH GOD
			- can move while dead
			- orcs teleport?

			Other
			- modularize displayHealth

			Could be better
			- determine action is array of functions?

			player:
			figure out where to act on
			figure out what action to take
			take action

			orc:
			if player is in range, attack. else, move.

			run ai, act
			[action, target] = run ai
			act(action, target)
			action = "move" or "attack"
			target = [x,y]

			run ai: decide

			act: implement

			*/
		</script>
	</head>
	<body>
		<div id="health">ur health iz glitched</div>
		<div id="map">ur code fayld</div>
		<div id="eventLog"></div>
	</body>
</html>